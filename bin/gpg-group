#!/usr/bin/env bash
#
# Manage and encrypt to groups of Gnupg keys
#


##################################################
# User Interface
##################################################


# fun: die message
# param: message: the message to ouptut to stdout
# txt: prints to stdout and exits w/ 1
die() {
	echo "gpg-group: ERROR: ${FUNCNAME[1]}: $1" >&2
	exit 1
}

##################################################
# Methods
##################################################

# fun: pick_group group
# param: group: group to pick
# txt: interactively prompts for group if none selected,
#      and validates that group exists
pick_group()
{
    local group="$1"
    if [[ -z "$group" ]]; then
        PS3='Select group: '
        select group in $(cmd_groups); do
            [[ "$group" ]] && break
        done
    fi

    has_group "$group" || die "Invalid group: $group"
    printf "%s" "$group"
}

# fun: pick_key fpr_uids
# param: fpr_uids: "fingerprint uid" lines to choose from
# txt: interactive menu to select a fingerprint.
#      presents uids, outputs a fingerprint or other selection
#      returns 0 if fpr selected, or 1 if other selection
pick_key() {
    local fprs uids choice i

    if [[ -z "$1" ]]; then
        printf 'No keys to choose from!\n' >&2
        read -r -p "$PS3"
        printf '%s' "$REPLY"
        return 1;
    fi

    mapfile -t fprs < <(fpr <<< "$1")
    mapfile -t uids < <(uid <<< "$1")

    select choice in "${uids[@]}"; do
        [[ $choice ]] || break
        for i in "${!uids[@]}"
        do
            if [[ "$choice" == "${uids[$i]}" ]]; then
                printf '%s' "${fprs[$i]}"
                return 0
            fi;
        done
    done;
    printf '%s' "$REPLY"
    return 1
}

# fun: has_group group
# param: group: group to check for existence
# txt: checks if group exists
has_group() {
    [[ -f "$homedir/$1" ]]
}

# fun: read_group group
# param: group: group to read keys from
# txt: outputs fingerprints from group. removes comments and blank lines
read_group() {
    sed -e 's/#.*//g' -e '/^$/d' -e 's/[[:space:]]//g' < "$homedir/$1"
}

# fun: write_group group fingerprints
# param: group: group name
# param: fingerprints: fingerprints of group
# txt: writes to file in format "fpr # uid"
write_group() {
    local group="$1"; shift

    if (( $# > 0 )); then
        list_keys "$@" |
            valid_fpr_uid |
            sort |
            uniq -w 40 |
            sort -k2 |
            sed 's/ / # /' > "$homedir/$group"
    else
        true > "$homedir/$group"
    fi
}

# fun: list_keys query
# param: query: query to search keys with
# txt: outputs gpg public keys in --with-colons format
list_keys() {
    gpg --list-public-keys --with-colons --with-fingerprint "$@"
}

# fun: valid_fpr_uid
# txt: reads --with-colons format from stdin and outputs "fpr uid" format of
#      valid keys and uid
valid_fpr_uid() {
    awk -F: '
        /^pub:/{ VALID = $2};
        /^fpr:/{ FPR = $10 };
        /^uid:/{ if(VALID~/[^ner]/ && $2~/[^ner]/) {print FPR " " $10;} ; }
        '
}

# fun: without_keys fingerprints
# params: fingerprints to remove
# txt: reads fpr_uid format from stdin and remove entries for specififed
#      fingerprints
without_keys() {
    if (("$#")) ; then
        grep -vf <(printf '^%s\n' "$@")
    else
        cat
    fi
}

# fun: uid
# txt: reads fpr_uid format from stdin and outputs uid
uid() {
    cut -d" " -f 2-
}

# fun: fpr
# txt: reads fpr_uid format from stdin and outputs fpr
fpr() {
    cut -d" " -f 1
}

# fun: is_clean group selected
# param: group: name of group to check
# param: selected: currently selected fingerprints
# txt: returns 1 if selected differs from group on disk
is_clean() {
    local group="$1";
    shift
    diff -q <(read_group "$group" | sort ) \
        <( (($#)) && printf '%s\n' "$@" | sort) > /dev/null
}

##################################################
# Commands
##################################################

# fun: cmd_usage
# txt: print usage to stdout
cmd_usage() {
    echo "usage"
}

# fun: cmd_groups
# txt: list all available groups
cmd_groups() {
    local group;
    for group in "$homedir"/*; do
        printf '%s\n' "${group##*/}"
    done;
}

# fun: cmd_show [-f] group
# opt: -f: change output to fingerprints instead of uids
# param: group: name of group to show memebers of
# txt: list members of a group, uid or fingerprint
cmd_show() {
    if [[ "$1" = "-f" ]];
        then display=fpr; shift; else display=uid;
    fi
    group=$(pick_group "$1")
    mapfile -t selected < <(read_group "$group")
    (( ${#selected[@]} > 0 )) && list_keys "${selected[@]}" | valid_fpr_uid | $display
}

# fun: cmd_prune [-n] group
# opt: -n: dont save changes
# param: group: the group to prune
# txt: rmeoves expired fingerprints from group
cmd_prune() {
    noact=false
    if [[ "$1" = "-n" ]]; then
        noact=true; shift
    fi

    group=$(pick_group "$1")

    mapfile -t selected < <(read_group "$group")
    mapfile -t active < <(cmd_show -f "$group")

    (( "${#selected[@]}" == "${#active[@]}" )) && return 1

    for s in "${selected[@]}"; do
        for a in "${active[@]}"; do
            [[ "$s" = "$a" ]] && continue 2
        done

        printf '%s\n' "$s"

    done
    $noact || write_group "$group" "${selected[@]}"
}

# fun: cmd_edit group
# param: group: group to edit
# txt: launch interactive edit group dialog
cmd_edit() {
    group=$(pick_group "$1")

    mapfile -t selected < <(read_group "$group")

    menu="[A]dd, [S]ave, [C]opy, [D]elete, [Q]uit: "

    while true; do

        # determine if group has been saved since editing
        if is_clean "$group" "${selected[@]}"
            then dirty=""; else dirty="*"
        fi

        # header
        printf 'Edit group "%s"%s (%s keys)\n' "$group" "$dirty" ${#selected[@]} >&2

        # config menu
        keys='';
        PS3="$menu"
        if (("${#selected[@]}" > 0)); then
            keys=$(list_keys "${selected[@]}" | valid_fpr_uid)
            PS3="[#] Remove key, $menu"
        fi

        # launch menu
        if fpr=$(pick_key "${keys[@]}"); then
            # Remove fpr from group
            for s in "${!selected[@]}"; do
                [[ ${selected[$s]} = "$fpr" ]] && unset 'selected[s]'
            done
        else
            # Launch other action
            case "$fpr" in
                A|a) # Search for and add FPR to group
                    read -r -p 'Search [type "C" to cancel]: ' query
                    [[ "$query" == "C" ]] && continue;
                    found=$(list_keys "$query" | valid_fpr_uid | without_keys "${selected[@]}")
                    PS3="Add to $group [C to cancel]: "
                    fpr=$(pick_key "${found[@]}") && selected+=("$fpr")
                    ;;
                S|s) # Save group
                    write_group "$group" "${selected[@]}"
                    ;;
                Q|q) # Quit
                    is_clean "$group" "${selected[@]}" && exit
                    read -r -p 'Changes not saved! Are you sure? [y/N]: '
                    [[ "$REPLY" = 'y' ]] && exit
                    ;;
                D|d) # Delete group
                    read -r -p "Delete $group? [y/N]: "
                    [[ "$REPLY" = 'y' ]] && rm "$homedir/$group" && exit
                    ;;
                C|c) # Copy group
                    name=''
                    while [[ -z "$name" ]] ; do
                        read -r -p "Enter name for new group copy: " name
                        has_group "$name" && unset name
                    done
                    write_group "$name" "${selected[@]}"
                    ;;
                *) printf 'Invalid Choice\n';
            esac
        fi
        printf '\n'
    done;
}

# fun: cmd_new name
# param: group: name of new group
# txt: creates new group and lunches interactive edit
cmd_new() {
    if [[ -z "$1" ]]; then
        read -r -p "Enter name for new group: " name
    else
        name=$1
    fi
    has_group "$name" && die "Group '$name' already exists"
    touch "$homedir/$name"
    cmd_edit "$name"
}

cmd_encrypt() {

    groups=()

    while :; do
        case "$1" in
            -g)
                if [ "$2" ]; then
                    groups+=("$2")
                    shift
                else
                    die '"--group" requires a non-empty option argument.'
                fi
                ;;
            --group=?*)
                group+=("${1#*=}")
                ;;
            --group=)
                die '"--group" requires a non-empty option argument.'
                ;;
            --)  shift ; break ;;
            -?*) printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2 ;;
            *)   break
        esac
        shift
    done

    for g in "${!groups[@]}"; do
        if ! has_group "${groups[$g]}"; then
            printf 'Invalid group %s\n' "${groups[$g]}" >&2
            unset 'groups[g]'
        fi
    done

    if (( "${#groups[@]}" < 1 )); then
        die "No groups. Aborting"
    fi

    rcpt=()
    for group in "${groups[@]}"; do
        while read -r line; do
            [[ -z "$line" ]] || rcpt+=("$line")
        done < <(read_group "$group")
    done

    ((${#rcpt[@]})) && mapfile -t rcpt < <(printf '%s\n' "${rcpt[@]}" | sort | uniq)

    if (( "${#rcpt[@]}" < 1 )); then
        die "No recipients. Aborting"
    fi

    rcpt_flags=( "${rcpt[@]/#/-r }" )

    for file in "$@"; do
        if [[ -d "$file" ]]; then
            archive="${file%/}".zip
            output="$archive".gpg
            zip -r - "$file" |
                gpg --set-filename "$archive" -e "${rcpt_flags[@]}" -o "$output"
        else
            output="${file%/}".gpg
            gpg -e "${rcpt_flags[@]}" -o "$output" "$file"
        fi
    done
}

##################################################
# Main
##################################################


## Global options
verbose=0
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
homedir="${GPG_GROUPS:-$XDG_DATA_HOME/gpg-groups}"

gpg="$(command -v gpg || command -v gpg2)"
if [[ -z ${gpg} && ! -x ${gpg} ]] ; then die "GnuPG is not available" ; fi

while :; do
    case "$1" in
        -v|--verbose) verbose=$((verbose + 1)) ;; # Each -v adds 1 to verbosity.
        --homedir)
            if [ "$2" ]; then
                homedir=$2
                shift
            else
                die '"--homedir" requires a non-empty option argument.'
            fi
            ;;
        --homedir=?*)
            homedir=${1#*=}
            ;;
        --homedir=)
            die '"--homedir" requires a non-empty option argument.'
            ;;
        --)  shift ; break ;;
        -?*) printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2 ;;
        *)   break
    esac
    shift
done

if [[ ! -d "$homedir" ]]; then
    mkdir -p "$homedir"
fi

cmd="$1"
shift

case "$cmd" in
    groups)   cmd_groups ;;
    show)     cmd_show "$@";;
    edit)     cmd_edit "$@";;
    new)      cmd_new "$@";;
    encrypt)  cmd_encrypt "$@";;
    prune)    cmd_prune "$@";;
    *) cmd_usage ;;
esac

